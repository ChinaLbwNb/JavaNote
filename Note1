package com.packageTest;

import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;
import com.sun.xml.internal.ws.wsdl.writer.document.Import;
import sun.security.mscapi.CPublicKey;

import java.util.Date;
import java.util.Scanner;
import java.util.Arrays;

/**
 * @author harrison
 * @version 1.0
 * @since 1.8
 */
public class HelloWorld {

    //1经典开头
    public static void main(String[] arg) {
        System.out.println("-------------------------------------------------------------------分割线 测试1.helloworld");
        System.out.println("Hello,World!");//不解释

        System.out.println("-------------------------------------------------------------------分割线 测试2.基本数据类型");
        //2基本数据类型
        int a = 10;
        float d = 2.8f;                  //屁股加字母
        long b = 39l;                    //屁股加字母，大写L为long对象 小写l才是基本数据类型
        byte c = (byte) a;//类型转换

        System.out.println("" + a + b);   //字符串写前面 后面的+变成拼接 而不运算

        System.out.println(a + b + "");   //字符串写后面前面要运算

        System.out.println(b % a);      //取余

        Date date = new Date();         //时间类 测试导入工具包的

        System.out.println("-------------------------------------------------------------------分割线 测试3.scanner类");
        //3 scanner类----------------------------------------------------------------------------------分割线

        Scanner scanner = new Scanner(System.in);//scanner类操作测试 属于io流
        System.out.println("请输入成绩：");
        int scores = scanner.nextInt();
        //next（）方法 来获取内容 并让程序等待用户输入完毕 再往下执行 注意：与nextLine区别
        //next方法输入的内容中 一旦有空格 输出的时候 空格后面的内容都没有了 nextLine方法可以有空格 用nextLine时 要对应hasNextLine

        if (scanner.hasNextInt()) {     //hNext()方法用来判断是否输入了内容
            System.out.println("scanner测试 输入的成绩为:" + scores);
        } else {
            System.out.println("你输入的不是整数");
        }
        scanner.close();         //io流的东西记得关 否则占资源很多

        System.out.println("-------------------------------------------------------------------分割线 测试4.if");
        //4 if判断-------------------------------------------------------------------------------------分割线

        if (scores < 60) {         //测试if else if多选择分支结构
            System.out.println("恭喜没及格");
        } else if (scores >= 60 && scores < 100) {
            System.out.println("恭喜及格，但没满分");
        } else if (scores == 100) {
            System.out.println("恭喜满分");
        } else if (scores >= 100) {
            System.out.println("输入的数字大于了100");
        }

        System.out.println("-------------------------------------------------------------------分割线 测试5.swtich语句");
        //5 swtich语句------------------------------------------------------------------分割线 switch-case测试

        switch (scores) {     //本质是匹配机制 用scores来与case后面的值进行匹配 匹配到哪个就输出哪个 ,可以用int short byte char
            // string也可以 case标签与switch后面的类型保持一致 不然怎么匹配捏
            case 60:
                //此处写语句
                break;      //可以不写break 但是会穿透 就是说 如果执行了case 60且没有break 则后面全部都会执行，所以尽量写
            case 70:
                //此处写语句
                break;
            default:        //上面情况都不匹配
                //写语句
        }

        System.out.println("-------------------------------------------------------------------分割线 测试6.while循环");
        //6 while语句
        while (scores < 100) {
            System.out.println("while测试 没满分 渣渣" + scores);
            scores++;

        }

        //while与do while区别 一个先判断在执行 一个先执行再判断 do至少执行一次语句 括号里面是个布尔值 与for循环区别 for里面有迭代体
        //不加迭代容易死循环
        System.out.println("-------------------------------------------------------------------分割线 测试do while循环");
        do {
            System.out.println("do while测试 没满分 渣渣" + scores);
            scores++;
        } while (scores < 100);

        System.out.println("-------------------------------------------------------------------分割线  测试7.for循环");
        //7 for循环
        for (int i = 1; i <= 5; i++) {   //只需输入数字.for 就可以生成对应循环次数的for循环
            int sum = 0;
            sum = sum + i;
            System.out.println(sum);
        }
        System.out.println("------------------------------------------------------------------分割线 测试7.1九九乘法表");
        for (int x = 1; x <= 9; x++) {
            for (int y = 1; y <= x; y++) {
                System.out.print(y + "*" + x + "=" + x * y + "\t");//每一次外部循环开始 内部循环的变量都被重置了 我以前不知道

            }
            System.out.println();
        }

        System.out.println("------------------------------------------------------------------分割线 7.2增强for循环");

        int[] array = {1, 2, 3, 4, 5}; //作用遍历数组或集合collection
        for (int z : array) {
            System.out.println(z);

        }

        System.out.println("------------------------------------------------------------------分割线 7.3测试break和continue");

        for (; a <= 20; a++) {
            System.out.println(a);
            if (a == 15) {
                break;
            }
        }
        System.out.println("break只是终止循环体里的语句 不影响外面的");

        while (a <= 20) {
            System.out.println(a);
            a++;
            if (a == 15) {
                continue;         //只跳出本次循环 接着执行下一次
            }
        }
        System.out.println("------------------------------------------------------------------分割线 测试8.方法method");
       //8. 方法method
        /**方法的格式
         *修饰符 返回值类型 方法名(参数类型 参数值){
         *
         *         方法体；
         *
         *         return 返回值;
         *         }
         *public static int add(int n,int m) {              //尼玛要写在main方法外面才行
         *
         *             return n+m;
         *}


         */

        int e = add(1, 5); //调用add方法
        System.out.print(e);

        int f = add(1.5, 2.0);//测试方法重载（编译器自行匹配实参输入的类型来调用符合的方法）
        System.out.println(f);

        int g = add(1, 2, 3, 4, 5, 6, 7, 8, 9);//测试可变参数 实质是数组
        System.out.println(g);
        System.out.println("------------------------------------------------------------------分割线 测试9.数组");
        //9 数组-------------------------------------------------------------------------------数组测试
        int[] num = new int[10];//动态初始化。
        int[] num2 = {1, 2, 4, 5, 6, 8};//静态初始化，声明+赋值。
        num[0] = 1;//数组元素单独赋值
        //不管哪种，一旦创建数组长度不可改变 长度合法区间[0,lenth-1]
        //数组本质是对象 其元素是对象的成员变量 存储在堆中
        int[][] two = new int[5][5];//二维数组

        //--------------------------------------------------------------------------Arrays类测试

        System.out.println(Arrays.toString(num2));//先写类再写方法名，Arrays.toString方法


        System.out.println("------------------------------------------------------------------分割线 测试10.冒泡排序");
        //10.冒泡排序-----------------------------------------------------------------------------冒泡排序   双重循环
        int temp;//定义零时变量用于交换两个元素
        int[] nums3 = {5, 4, 3, 2, 1};
        for (int h = 0; h <= nums3.length - 1; h++) {  //需要进行比较的轮数
            for (int k = 0; k < nums3.length - 1 - h; k++) {
                if (nums3[k] > nums3[k + 1]) {
                    temp = nums3[k];
                    nums3[k] = nums3[k + 1];
                    nums3[k + 1] = temp;
                }
            }
        }
        System.out.println(Arrays.toString(nums3));


        System.out.println("------------------------------------------------------------------分割线 测试11.static");
        //11.static（静态）和非静态-----------------------------------------------------------------------测试静态方法static和非静态方法不加static

        HelloWorld.say1();
        HelloWorld say = new HelloWorld();
        say.say2();     //测试结果表明 静态方法可直接用 类.方法(); 调用 ，非静态方法方法需要实例化一个所在类，用该类的对象来调 对象.方法();
                        //原理：static方法是和类一起加载，而非static是对象创建后才存在 (这句话谨记)
                        //更新解释 static的方法归属于类 非static归属于对象

        System.out.println("------------------------------------------------------------------分割线 测试12.类和对象的创建");
        //12.测试类和对象的创建--------------------------------------------------------------------------测试类和对象的创建

        //类是抽象的，需要实例化成对象
        studentTest jack=new studentTest();
        jack.name="jack";
        jack.age=15;
        System.out.println(jack.name + jack.age);

        System.out.println("------------------------------------------------------------------分割线 测试13.构造器");
        //13.-----------构造器（构造方法）知识点---> 使用new关键字时 一定会通过构造方法 来获得初始值
        // 1*方法名必须和类名相同
        // 2*不能写任何返回类型，void也不行
        // 3* alt+insert 快捷键生成构造器
        // 4* 定义有参构造器必须要显示定义无参
        studentTest LBW=new studentTest();

        System.out.println("------------------------------------------------------------------分割线 测试14.封装继承");
        //14.----------------------------------------------封装，继承，多态
        //1*封装，一般属性封装起来用private修饰，然后为外界提供get，set方法（手写）
        System.out.println(jack.getHeight());
        jack.setHeight(10);
        System.out.println(jack.getHeight());

        //2*继承
        //继承父类的属性和方法可直接使用，但私有属性无法直接使用（本质是继承了的，不能直接用），可用get方法获得
        //所有类都是继承了object类的 java.lang包中的 祖宗类 （jdk自动加了extends Object）
        student2 lucy=new student2(); //继承父类后 new对象将首先调用父类构造器然后调用子类构造器（都要调）


        //3* super关键字
        //作用是指向父类  所以只能在子类中写 与this关键字类似
        //this指向本类，super指向父类
        lucy.demo1();//妈的 方法只能对象来掉 我日

        //4*方法重写/覆盖  （只有方法重写，属性不存在重写） alt+insert

        //5*多态： 继承关系父类盒子类之间相同方法名 方法块不同 重写后 构成多态
        //而同个方法中 相同方法名不同参数构成重载 这两个是相似的 多态和重载 多个类之间的方法叫多态 同个类中的方法叫重载


        System.out.println("------------------------------------------------------------------分割线 测试15.instanceof二元运算符 和类类型转换");
        //15.instanceof二元运算符 和类类型转换
        /**
         *  x instanceof y  判断x是否是y的对象 或 是否是y子类的对象
         */
        System.out.println(lucy instanceof studentTest);

        //低转高 向上转型 自动转
        studentTest lbw=new student2(); //区别是 走了子类的构造方法 但不能直接用子类的普通方法
        //高转低 向下转型 强制手动转 所以才能用子类方法
        ((student2)lbw).go();//父类想用子类的方法 就这样强转
        student2 lll=(student2) lbw;//先有向上转 再有向下转



        //16* static详解
        // static记住一件事 ，和类一起加载 可以用类来调static方法 非static和对象一起加载
        //static{  }代码块 一样的和类一起加载 只运行一次
        //final断子绝孙 不可修改不可继承



        //17* 抽象类 abstract关键字修饰
        //a.不能实例化一个对象出来，必须靠子类实现，相当于在写规范，一种约束
        //b.抽象类里以写普通方法 普通类不能写抽象方法
        //c.继承了的子类必须重写抽象方法



        //18* 接口interface 和类class 同级 interface 和抽象类类似 不同点是接口可以多继承
        //接口不能实现 甚至不是一个类
        //和抽象类一样 继承了必须重写方法 接口里面的都是抽象的
        //implements关键字 等价与 extends


        //19* 内部大类 有四种
         class inner{ //这就是第一种成员内部类 可以获得外部类的属性（包括私有）
             private  void GO(){
             class jubuInner{ }//这是第二种局部内部类 卸载方法里面的内部类

             }
         }

         new inner().GO();//这里没有将对象保存进一个名字 称为匿名对象


         //第三种静态内部类 public static class inner{}  区别是static优先加载 所以无法获取外部类的非静态属性
        //第四种匿名内部类 作用节省代码

        System.out.println("------------------------------------------------------------------分割线 测试20.异常机制");
        //20* 异常 try catch finally throw throws
        int i=1;
        int p=0;
        try {                       //try里面是监控区域  选中语句ctrl+alt+t
            System.out.println(i/p);//分母为零
        } catch (Exception ex) {    //catch括号里面写的是匹配的异常类型 这里和switch case类似 可写多个catch 从第一个开始匹配 匹配成功后执行该catch跳出，再执行finally
            System.out.println("出异常啦");
        } finally {                 //处理善后 以后的io流 关资源 //可以不写
            System.out.println("finally无论怎样都要执行");
        }
                                    //最大异常类 Throwable 分支两个 Error（分栈溢出和内存溢出） 和 Exception（分io异常和runtime异常）

        //自定义异常 手写一个类继承Exception
        System.out.println("------------------------------------------------------------------分割线 测试21。常用类.Math类");
        //21*常用类 （API)
        //*1 Math类 lang包中 使用无需导包
        System.out.println(Math.abs(-88)); //返回绝对值
        System.out.println(Math.ceil(1.35));//返回整数 向上取整 ，英文直译天花板
        System.out.println(Math.floor(1.35));//返回整数，向下取整，英文直译地板
        System.out.println(Math.round(1.35));//返回整数，四舍五入。
        System.out.println(Math.max(1,2));//两数相比反其大 还有min方法
        System.out.println(Math.pow(2,4));// 返回2的四次方
        System.out.println(Math.random());//返回0~1的随机数
        System.out.println("------------------------------------------------------------------分割线 测试21.2 system类");

        //*2 System类 lang包中 使用无需导包

        System.out.println("start");
        //System.exit(0);   该方法 终止当前运行的Java虚拟机，非零表示异常中止
        System.out.println("exit");

        System.out.println(System.currentTimeMillis()); //返回当前时间与1970-1-1的毫米差值
        System.out.println("距离1970年1月1日  "+System.currentTimeMillis()/1000.0/3600/24/365+"年");

        System.out.println("------------------------------------------------------------------分割线 测试21.3 Object类");


        //*3  Object类  lang包中 无需导入 祖宗类 所有类都直接间接继承Object类
        System.out.println(lucy.toString()); //toString获取对象的信息 ，建议所有子类重写 不然返回的是对象地址
        System.out.println(lbw.equals(lucy));//对象内容的比较用equals方法 不能用==  也要重写不然比较地址值 alt+insert在类里面重写
        //总结 记得重写tostring 和equals

        //*4 Arrays类(大写加s) util类中 需导包
        int[] arr={7,9,8,2};
        System.out.println("排序前"+Arrays.toString(arr));//Arrays.toString获取数组
        Arrays.sort(arr);                                //Araays.sort排序 效率不如冒泡
        System.out.println("排序后"+Arrays.toString(arr));

        //*5包装类 八大基本类型本别对应自己的包装类
        Integer i1=Integer.valueOf(100);  //创建Integer对象并赋值   不能使用 new Integer（）； 因为已经过时
        //其他类型 long--Long float--Float char--Character 除了int 和 char 以外都只是把首字母变大写

        //StringBuilder  存在的原因：为了解决string浪费资源的情况 每次对string操作就会生成新的对象 浪费资源 而stringbuilder可以直接更改 可变字符序列
        StringBuilder sb=new StringBuilder();
        sb.append("hello").append("fuck").append("you");//append方法 和链式编程 对象可以连续调方法
        sb.reverse();//反转所有字符的方法
        System.out.println(sb);
        //SringBuilder与String的转换

        String sb2= sb.toString(); //stringbuilder转string   使用toString方法可以将值赋给String

        StringBuilder sb3=new StringBuilder(sb2); //String转stringbuilder  构造方法传参









    }





    //main方法以外区域========================================================================方法测试 main方法之外区域


    public static int add(int n, int m) { //尼玛要写在main方法外面才行 方法内部不能写方法
        return n + m;
    }

    public static int add(double n, double m) { //(互推)构成方法重载<<=>>方法名必须相同 形式参数必须不同（不同体现在 形参个数和类型） 返回值可同可不同
        return (int) (n + m);                  //简单来说就是一个类中 方法名一样但形参不一样的两个方法 或多个
    }

    public static int add(int... n) { //可变参数 其实就是数组 形参变成了形式数组 只能定义一个且必须写在最后一个 格式是在类型后面加省略号
        return n.length;
    }

    //===================================================================================面向对象测试
    public static void say1() {  //对照组1
        System.out.println("hello,motherFucker");
    }

    public void say2() {  //对照组2 没加static
        System.out.println("hello,motherFucker");
    }

}
